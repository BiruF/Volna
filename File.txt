#include <iostream>
#include <ctime>
#include <string>

using namespace std;

class Labyrinth 
{
private:
	int** POLE;
	int N;
	int M;
public:
	Labyrinth()
	{
		N = M = 7;
		POLE = new int* [N];
		for (int i = 0; i < 7; i++)
		{
			POLE[i] = new int[M];
		}
	}
	Labyrinth(int n_size, int m_size)
	{
		N = n_size;
		M = m_size;
		POLE = new int* [N];
		for (int i = 0; i < N; i++)
		{
			POLE[i] = new int[M];
		}
	}
	~Labyrinth()
	{
		for (int i = 0; i < N; i++)
		{
			delete POLE[i];
		}
		delete[]POLE;
	}
	void Create_lab()
	{
		cout << "Построение карты: " << endl << endl;
		for (int i = 0; i < N; i++) {
			int j = 0;
			POLE[i][j] = -1;
			j = M-1;
			POLE[i][j] = -1;
		}
		for (int j = 0; j < M; j++) {
			int i = 0;
			POLE[i][j] = -1;
			i = N-1;
			POLE[i][j] = -1;
		}
		for (int i = 1; i < (N - 1); i++) {
			for (int j = 1; j < (M - 1); j++)
				POLE[i][j] = 0;
		}
		int c = (M-2)*(N-2)*0.3;
		while (c != 0) {
			int i = rand() % (N-1) + 1, j = rand() % (M - 1) + 1;
			POLE[i][j] = -1;
			c--;
		}
	}
	void write()
	{
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				cout << POLE[i][j] << "\t ";
			}
			cout << endl << endl;
		}
	}
	void spisok() {
		cout << "Список путых ячеек для дальнейшего выбора начала и конца в лабиринте: " << endl;
		for (int i = 1; i < N-1; i++)
		{
			for (int j = 1; j < M-1; j++)
			{
				if (POLE[i][j] == 0) cout << "[i] = " << i << " [j] = " << j << endl;
			}
		}
	}
	void Volna(const int X1, const int Y1, const int X2, const int Y2)
	{
		int i, j;
		string** Put = new string* [this->N];
		for (i = 0; i < this->N; i++)
		{
			Put[i] = new string[this->M];
		}
		if (POLE[X1][Y1] == -1 || POLE[X2][Y2] == -1) {
			cout << "Неверно подобраны координаты для входа или выхода лабиринта";
			return;
		}
		POLE[X1][Y1] = -2;
		POLE[X2][Y2] = -3;

		int shag = 1;
		int count = 0;
		bool a = true;
		while (a) {
			a = false;
			for (i = 1; i < N - 1; i++)
			{
				for (j = 1; j < M - 1; j++)
				{
					if (POLE[i][j] != -3 && POLE[i][j] != 0 && POLE[i][j] != -1 && POLE[i][j] != shag) {
						for (int z = i - 1; z <= i + 1; z++)
						{
							for (int g = j - 1; g <= j + 1; g++)
							{
								if (POLE[z][g] == 0 || POLE[z][g] == -3) {
									POLE[z][g] = shag;
									count++;
									a = true;
								}
							}
						}
					}
				}
			}
			shag++;
		}
		cout << "Кол-во пройденных ячеек: " << count << endl;
		if (POLE[X2][Y2] == -3) {
			cout << "Выход не найден!" << endl;
			return;
		}
		int Long = POLE[X2][Y2];
		POLE[X1][Y1] = 0;
		for (int i = 0; i < N; i++)
		{
			for (int j = 0; j < M; j++)
			{
				cout << POLE[i][j] << "\t ";
			}
			cout << endl << endl;
		}
		cout << endl;
		int X = X2, Y = Y2;
		while (POLE[X1][Y1] == 0) {
			j = Y - 1;
			for (i = X - 1; i <= X + 1; j++) {
				if ((POLE[X][Y] - POLE[i][j]) == 1) {
					POLE[X][Y] = -4;
					X = i;
					Y = j;
					break;
				}
				if (j == (Y + 2)) {
					j = Y - 2;
					i++;
				}
			}
		}
		for (i = 0; i < N; i++)
		{
			for (j = 0; j < M; j++)
			{
				switch (POLE[i][j])
				{
				case -1:
					Put[i][j] = 'X';
					break;
				case -4:
					Put[i][j] = '*';
					break;
				default:
					int dig;
					char c;
					while (POLE[i][j] != 0) {
						dig = POLE[i][j] % 10;
						POLE[i][j] /= 10;
						c = (char)(dig + 48);
						Put[i][j] = c + Put[i][j];
					}
					break;
				}
			}
		}
		Put[X1][Y1] = 'A';
		Put[X2][Y2] = 'B';
		for (i = 0; i < N; i++)
		{
			for (j = 0; j < M; j++)
			{
				cout << Put[i][j] << "\t  ";
			}
			cout << endl << endl;
		}
		cout << endl;
		cout << "Длина кратчайшего пути в лабиринте = " << Long;
	}
};

int main()
{
	srand(time(0));
	setlocale(LC_ALL, "Rus");
	int n, m, c;
	cout << "Введите размеры лабиринта: " << endl;
	cin >> n;
	cin >> m;
	Labyrinth L1(n, m);
	L1.Create_lab();
	cout << "Массив для построения карты: " << endl << endl;
	L1.write();
	L1.spisok();
	int X1, Y1, X2, Y2;
	cout << "Введите координаты начала и конца лабиринта:\nX1 = ";
	cin >> X1;
	cout << "\nY1 = ";
	cin >> Y1;
	cout << "\nX2 = ";
	cin >> X2;
	cout << "\nY2 = ";
	cin >> Y2;
	cout << "Распространение волны: " << endl << endl;
	L1.Volna(X1, Y1, X2, Y2);
}